@import: lib/spy
@import: ../src/expect
@import: ../src/test-case
@import: ../src/test-run-result

% Todo
% x call test method
% x multiple tests
% x count test runs
% x count failure results
% aggregate which test ran and failed

open Test in
let result = describe `satysfi-test` [
  describe `Spy` [
    test `was-run is false initially` (fun () -> (
      let spy = Spy.make () in
      spy |> Spy.was-run |> Expect.is-false
    ));
    test `was-run is true when test-fun is called` (fun () -> (
      let spy = Spy.make () in
      let _ = (spy |> Spy.get-spy) () in
      spy |> Spy.was-run |> Expect.is-true
    ))
  ];

  describe `Test` [
    test `test calls test body` (fun () -> (
      let spy = Spy.make () in
      let _ = test `Mock test case` (spy |> Spy.get-spy) |> run in
      spy |> Spy.was-run |> Expect.is-true
    ));

    test `describe calls all test cases` (fun () -> (
      let (spy1, spy2) = (Spy.make (), Spy.make ()) in
      let _ = describe `Multiple test cases` [
        test `Test case 1` (spy1 |> Spy.get-spy);
        describe `Nested describe` [
          test `Test case 2` (spy2 |> Spy.get-spy);
        ]
      ] |> run in
      ((spy1 |> Spy.was-run) && (spy2 |> Spy.was-run))
      |> Expect.is-true
    ));
  ];

  describe `TestRunResult` [
    test `1 success with a single successful test case` (fun () -> (
      let result = test `Mock test case` (fun () -> (
        Expect.always-pass
      )) |> run in
      (result |> TestRunResult.count-run) == 1
      && (result |> TestRunResult.count-success) == 1
      |> Expect.is-true
    ));
    test `1 failure with a single failing test case` (fun () -> (
      let result = test `Mock test case` (fun () -> (
       Expect.always-fail
      )) |> run in
      (result |> TestRunResult.count-run) == 1
      && (result |> TestRunResult.count-success) == 0
      |> Expect.is-true
    ));
    test `describe aggregates TestRunResult` (fun () -> (
      let result = describe `Mock describe` [
        test `success 1` (fun () -> Expect.always-pass);
        test `success 2` (fun () -> Expect.always-pass);
        test `fail 3` (fun () -> Expect.always-fail);
      ] |> run in
      (result |> TestRunResult.count-run) == 3
      && (result |> TestRunResult.count-success) == 2
      |> Expect.is-true
    ))
  ];

  %% Uncomment following lines to have a failing test case
  % test `Test can fail` (fun () -> (
  %   Expect.always-fail
  % ));

  % We cannot use Expect because it's the very test subject!
  let assert b = if b then ExpectResult.pass else  ExpectResult.fail in
  describe `Expect` [
    test `always-pass` (fun () -> (
      Expect.always-pass |> ExpectResult.is-pass |> assert
    ));
    test `always-fail` (fun () -> (
      Expect.always-fail |> ExpectResult.is-pass |> (not) |> assert
    ));
    test `true passes when true is passed` (fun () -> (
      Expect.is-true true |> ExpectResult.is-pass |> assert
    ));
    test `true fails when false is passed` (fun () -> (
      Expect.is-true false |> ExpectResult.is-pass |> (not) |> assert
    ));
    test `false passes when false is passed` (fun () -> (
      Expect.is-false false |> ExpectResult.is-pass |> assert
    ));
    test `false fails when true is passed` (fun () -> (
      Expect.is-false true |> ExpectResult.is-pass |> (not) |> assert
    ));
  ]
] |> run in

let stringify-result result =
  open TestRunResult in
  let run-count = result |> count-run in
  let success-count = result |> count-success in
  #`Test result : `#
  ^ (arabic run-count) ^ #` run, `#
  ^ (arabic success-count) ^ #` success, `#
  ^ (arabic (run-count - success-count)) ^ #` fail`# in

let message = result |> stringify-result in
let () = message |> display-message in
message
